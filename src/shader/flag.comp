R"===(

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

uniform layout(binding = 0, rgb10_a2ui) uimageBuffer flist_P;
uniform layout(binding = 1, r32ui) uimageBuffer octree_nodes;
uniform u32 octree_level;
uniform u32 octree_resolution;
uniform u32 fragment_count;

#define MSB 0x80000000

void main()
{
    u32 thx_id = gl_GlobalInvocationID.y * 1024 + gl_GlobalInvocationID.x;
    if (thx_id < fragment_count)
    {
        // Top-Down
        u32 first_idx_of_cur_level  = 0;
        u32 voxel_count             = 1;
        u32 res                     = 1;
        u32 voxel_size              = octree_resolution;

        uv4 voxel_coord = imageLoad(flist_P, s32(thx_id));

        for (u32 level = 0;
             level < octree_level;
             ++level)
        {
            u32 x = voxel_coord.x / voxel_size;
            u32 y = voxel_coord.y / voxel_size;
            u32 z = voxel_coord.z / voxel_size;

            u32 offset = z * res*res +
                         y * res     +
                         x;
            s32 idx_in_pool = s32(first_idx_of_cur_level + offset);
            u32 node = imageLoad(octree_nodes, idx_in_pool).r;
            node |= MSB;
            imageStore(octree_nodes, idx_in_pool, uv4(node, 0, 0, 0));


            res <<= 1;
            first_idx_of_cur_level += voxel_count;
            voxel_count <<= 3;
            voxel_size >>= 1;
        }




#if 0
        b32 flag = true;
        s32 child_idx = 0;

        u32 voxel_dim = octree_resolution;

        uv4 loc = imageLoad(flist_P, s32(thx_id));

        uv3 umin = uv3(0);
        uv3 umax = uv3(voxel_dim);

        u32 node = imageLoad(octree_nodes, 0).r;
        u32 subnode;

        for (u32 i = 0;
             i < octree_level;
             ++i)
        {
            voxel_dim /= 2;
            if ((node & MSB) == 0)
            {
                flag = false;
                break;
            }
            else
            {
                child_idx = s32(node & 0x7fffffff);

                subnode = clamp(s32(1 + loc.x - umin.x - voxel_dim), 0, 1);
                subnode += 4 * clamp(s32(1 + loc.y - umin.y - voxel_dim), 0, 1);
                subnode += 2 * clamp(s32(1 + loc.z - umin.z - voxel_dim), 0, 1);
                child_idx += s32(subnode);

                umin.x += voxel_dim * clamp(s32(1 + loc.x - umin.x - voxel_dim), 0, 1);
                umin.y += voxel_dim * clamp(s32(1 + loc.y - umin.y - voxel_dim), 0, 1);
                umin.z += voxel_dim * clamp(s32(1 + loc.z - umin.z - voxel_dim), 0, 1);

                node = imageLoad(octree_nodes, child_idx).r;
            }
        }

        if (flag)
        {
            node |= MSB;
            imageStore(octree_nodes, child_idx, uv4(node, 0, 0, 0));
        }
#endif
    }
}

)===";
